/**
 * Like Array but tracks.
 *
 * 1. Instances are supposed to be used Proxied, so theres no need for
 *    batching, because the proxy already batches the functions.
 * 2. This is an internal Class and is not meant to be used outside
 *    `mutable`.
 */
export class ReactiveArray extends Array<any> {
    [x: symbol]: import("../tracker.js").Track | (() => Generator<any, void, unknown>);
    constructor(arrayLength?: number);
    constructor(arrayLength: number);
    constructor(...items: any[]);
    splice(start: any, deleteCount: any, ...items: any[]): any[];
    sort(compareFn: any): this;
    forEach(callback: any, thisArg: any): void;
    map(callback: any, thisArg: any): any[];
    every(predicate: any, thisArg: any): boolean;
    some(predicate: any, thisArg: any): boolean;
    fill(...args: any[]): this;
    copyWithin(...args: any[]): this;
    toLocaleString(): string;
    slice(start: any, end: any): any[];
    join(separator: any): string;
    concat(...items: any[]): any[];
    indexOf(searchElement: any, fromIndex: any): number;
    lastIndexOf(searchElement: any, fromIndex: any): number;
    filter(predicate: any, thisArg: any): any[];
    reduce(...args: any[]): unknown;
    reduceRight(...args: any[]): unknown;
    find(predicate: any, thisArg: any): any;
    findIndex(predicate: any, thisArg: any): number;
    entries(): Generator<[number, any], void, unknown>;
    keys(): Generator<number, void, unknown>;
    values(): Generator<any, void, unknown>;
    includes(searchElement: any, fromIndex: any): boolean;
    flat(depth: any): any[];
    flatMap(callback: any, thisArg: any): any[];
    at(key: any): any;
    findLast(predicate: any, thisArg: any): any;
    findLastIndex(predicate: any, thisArg: any): number;
    toSorted(compare: any): any[];
    toSpliced(start: any, deleteCount: any, ...items: any[]): any[];
    with(key: any, value: any): any[];
}
//# sourceMappingURL=array.d.ts.map