/**
 * Marks a function as reactive. Reactive functions are ran inside
 * effects.
 *
 * @param {Function} fn - Function to mark as reactive
 * @returns {Function}
 */
export function markReactive(fn: Function): Function;
/**
 * Creates a new root
 *
 * @param {(dispose: () => void) => any} fn
 * @param {object} [options]
 * @returns {any}
 */
export function root(fn: (dispose: () => void) => any, options?: object): any;
/**
 * Creates a signal
 *
 * @template T
 * @param {T} [initialValue] - Initial value of the signal
 * @param {SignalOptions} [options] - Signal options
 */
export function signal<T>(initialValue?: T, options?: SignalOptions): Signal<T>;
/**
 * Creates an effect
 *
 * @param {Function} fn
 * @param {object} [options]
 */
export function effect(fn: Function, options?: object): void;
/**
 * Creates an effect with explicit dependencies
 *
 * @param {Function} depend - Function that causes tracking
 * @param {Function} fn - Function that wont cause tracking
 * @param {object} [options]
 */
export function on(depend: Function, fn: Function, options?: object): void;
/**
 * Creates a syncEffect
 *
 * @param {Function} fn
 * @param {object} [options]
 */
export function syncEffect(fn: Function, options?: object): SyncEffect;
/**
 * Creates a read-only signal from the return value of a function that
 * automatically updates
 *
 * @template T
 * @param {T} fn - Function to re-run when dependencies change
 * @param {SignalOptions} [options]
 * @returns {SignalAccessor<T>} - Read only signal
 */
export function memo<T>(fn: T, options?: SignalOptions): SignalAccessor<T>;
/**
 * Returns current owner
 *
 * @returns {typeof Owner}
 */
export function owner(): typeof Owner;
/**
 * Disables tracking for a function
 *
 * @param {Function} fn - Function to run with tracking disabled
 * @returns {any}
 */
export function untrack(fn: Function): any;
/**
 * Runs a callback on cleanup, returns callback
 *
 * @template T
 * @param {T} fn
 * @returns {T}
 */
export function cleanup<T>(fn: T): T;
/**
 * Creates a context and returns a function to get or set the value
 *
 * @param {any} [defaultValue] - Default value for the context
 */
export function Context(defaultValue?: any): () => import("pota/jsx-runtime").JSX.Element;
/**
 * A self contained signal function, when an argument is present it
 * writes to the signal, when theres no argument it reads the signal.
 *
 * @template T
 * @param {T} [value] - Optional initial value
 * @returns {SignalFunction<T>}
 */
export function signalFunction<T>(value?: T): SignalFunction<T>;
/**
 * Runs a function inside an effect if value is a function.
 * Aditionally unwraps promises.
 *
 * @param {any} value
 * @param {(value) => any} fn
 */
export function withValue(value: any, fn: (value: any) => any): void;
/**
 * Runs a function inside an effect if value is a function
 *
 * @param {any} value
 * @param {(value: any, prev?: any) => any} fn
 */
export function withPrevValue(value: any, fn: (value: any, prev?: any) => any): void;
/**
 * Lazy and writable version of `memo`, its writable and will run the
 * function only when used
 *
 * @author ryansolid
 * @param {Function} fn - Function to re-run when dependencies change
 * @returns {((...args) => any) | (() => any)}
 */
export function writable(fn: Function): ((...args: any) => any) | (() => any);
/**
 * Creates an asynchronously effect
 *
 * @param {(currentRunningEffect: Promise<any>) => any} fn - A
 *   function that receives a `currentRunningEffect` that should be
 *   awaited for when wanting to run effects synchronously, that's it
 *   one effect after another.
 */
export function asyncEffect(fn: (currentRunningEffect: Promise<any>) => any): void;
/**
 * Reactive Map
 *
 * @template T
 * @param {Each<T>} list
 * @param {Function} callback
 * @param {boolean} [sort]
 * @param {Children} [fallback]
 */
export function map<T>(list: Each<T>, callback: Function, sort?: boolean, fallback?: Children): (fn: Function) => Children;
/**
 * Resolves and returns `children` in a memo
 *
 * @param {Component | Children} fn
 * @url https://pota.quack.uy/resolve
 */
export function resolve(fn: Component | Children): SignalAccessor<() => string | number | any[] | ((props?: any) => import("pota/jsx-runtime").JSX.Element) | (new (props?: any) => import("pota/jsx-runtime").JSX.ElementClass)>;
/**
 * Returns true if the value can be made a Component
 *
 * @param {any} value
 * @returns {boolean}
 */
export function isComponentable(value: any): boolean;
/**
 * Makes of `children` a function. Reactive children will run as is,
 * non-reactive children will run untracked, regular children will
 * just return.
 *
 * @param {Children} children
 * @returns {Function}
 */
export function makeCallback(children: Children): Function;
/**
 * Marks a function as a `Component`.
 *
 * @template T
 * @param {T} fn - Function to mark as a `Component`
 */
export function markComponent<T>(fn: T): T;
/**
 * Adds an event listener to a node
 *
 * @param {Element | Document | typeof window} node - Element to add
 *   the event listener
 * @param {(keyof WindowEventMap & keyof GlobalEventHandlersEventMap)
 * 	| string} type
 *   - The name of the event listener
 *
 * @param {EventListener
 * 	| EventListenerObject
 * 	| (EventListenerObject & AddEventListenerOptions)} handler
 *   - Function to handle the event
 *
 * @returns {Function} - An `off` function for removing the event
 *   listener
 * @url https://pota.quack.uy/props/EventListener
 */
export function addEvent(node: Element | Document | typeof window, type: (keyof WindowEventMap & keyof GlobalEventHandlersEventMap) | string, handler: EventListener | EventListenerObject | (EventListenerObject & AddEventListenerOptions)): Function;
/**
 * Removes an event listener from a node
 *
 * @param {Element | Document | typeof window} node - Element to add
 *   the event listener
 * @param {(keyof WindowEventMap & keyof GlobalEventHandlersEventMap)
 * 	| string} type
 *   - The name of the event listener
 *
 * @param {EventListener
 * 	| EventListenerObject
 * 	| (EventListenerObject & AddEventListenerOptions)} handler
 *   - Function to handle the event
 *
 * @returns {Function} - An `on` function for adding back the event
 *   listener
 * @url https://pota.quack.uy/props/EventListener
 */
export function removeEvent(node: Element | Document | typeof window, type: (keyof WindowEventMap & keyof GlobalEventHandlersEventMap) | string, handler: EventListener | EventListenerObject | (EventListenerObject & AddEventListenerOptions)): Function;
export function isReactive(value: any): boolean;
export function batch(fn: any, init?: boolean): any;
export function owned(cb: Function | undefined): () => any;
export function proxy<T>(snigal: SignalAccessor<T>, target?: object): object;
export function ref<T>(): SignalFunction<T>;
export function lazy(fn: (() => Promise<any>) | Promise<any>, options?: {
    onLoading?: any;
    onLoaded?: Function;
    onError?: ((e: Error, retry: Function) => any) | any;
}): Component;
export function Lazy(props: any): import("pota/jsx-runtime").JSX.ElementType;
export function microtask(fn: any): void;
/**
 * Extend `Pota` and define a `render(props){}` method to create a
 * class component. `ready(cb)` and `cleanup(cb)` methods will be
 * registered automatically
 *
 * @url https://pota.quack.uy/Classes
 */
export class Pota {
}
export function isComponent(value: any): boolean;
export function ownedEvent(handler: any): any;
/** @template in T */
declare class Signal<in T> {
    /**
     * @param {T} [value]
     * @param {SignalOptions} [options]
     */
    constructor(value?: T, options?: SignalOptions);
    value: T | undefined;
    /** @private */
    private observers;
    /** @private */
    private observerSlots;
    /** @private */
    private prev;
    /** @returns SignalAccessor<T> */
    read: Function;
    /**
     * @param {T} [value]
     * @returns SignalSetter<T>
     */
    write: (value?: T) => boolean;
    /**
     * @param {T} [value]
     * @returns SignalUpdate<T>
     */
    update: (value?: T) => boolean;
    /** @private */
    private equals;
    [globalThis.Symbol.iterator](): Generator<Function, void, unknown>;
}
declare class SyncEffect extends Computation {
}
declare let Owner: any;
declare class Computation extends Root {
    constructor(owner: any, fn: any, options: any);
    state: number;
    updatedAt: number;
    fn: any;
    sources: any;
    sourceSlots: any;
    update(): void;
    queue(): void;
}
declare class Root {
    /** @param {undefined | Root} owner */
    constructor(owner: undefined | Root, options: any);
    /** @type {Root} */
    owner: Root;
    /** @type {Root | Root[] | null} */
    owned: Root | Root[] | null;
    /** @type {Function | Function[] | | null} */
    cleanups: Function | Function[] | any | null;
    /** @type {any} */
    context: any;
    addCleanups(fn: any): void;
    addOwned(value: any): void;
    dispose(): void;
    disposeOwned(): void;
    doCleanups(): void;
}
export {};
//# sourceMappingURL=reactive.d.ts.map