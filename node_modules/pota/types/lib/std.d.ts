export function copy(o: any): any;
export function entriesIncludingSymbols(target: any): Generator<any[], void, unknown>;
export function equals(a: any, b: any): boolean;
export function getSetterNamesFromPrototype(object: any, set?: Set<any>): Set<any>;
/**
 * Unwraps values. If the argument is a function then it runs it
 * recursively and returns the value
 *
 * @param {Function | any} value - Maybe function
 * @returns {any}
 */
export function getValue(value: Function | any): any;
/**
 * Unwraps `value` and returns `element` if result is a `Node`, else
 * `undefined` in the case isn't a `Node`
 *
 * @param {Function | any} value - Maybe function
 * @param {...any} args? - Arguments
 * @returns {Node | undefined}
 */
export function getValueElement(value: Function | any, ...args: any[]): Node | undefined;
export function range(start: any, stop: any, step?: number): Generator<any, void, unknown>;
/**
 * Removes a value from an array
 *
 * @template T
 * @param {T[]} array
 * @param {T} value To remove from the array
 */
export function removeFromArray<T>(array: T[], value: T): void;
/**
 * Removes values from an array based on a condition
 *
 * @template T
 * @param {T[]} array
 * @param {(value: T, index: number) => boolean} cb Function with
 *   condition
 */
export function removeFromArrayConditionally<T>(array: T[], cb: (value: T, index: number) => boolean): void;
/**
 * Removes values from an array based on a condition
 *
 * @param {Iterable<object | any[]>} iterable
 * @param {PropertyKey} key Function with condition
 */
export function indexByKey(iterable: Iterable<object | any[]>, key: PropertyKey): any;
/**
 * Replace a prototype in the prototype chain with another prototype
 *
 * @param {object} target - Target object
 * @param {object} search - The prototype to replace
 * @param {object} replacement - The replacement prototype
 */
export function replacePrototypeWith(target: object, search: object, replacement: object): void;
export function walkParents(context: any, propertyName: any, cb: any): true | undefined;
/**
 * Adds a style sheet to the custom element
 *
 * @param {Document | ShadowRoot} document
 * @param {(CSSStyleSheet | string)[]} styleSheets
 */
export function addStyleSheets(document: Document | ShadowRoot, styleSheets?: (CSSStyleSheet | string)[]): void;
export function stopEvent(e: any): void;
export const global: typeof globalThis;
export const window: typeof globalThis;
export const CSSStyleSheet: {
    new (options?: CSSStyleSheetInit): CSSStyleSheet;
    prototype: CSSStyleSheet;
};
export const document: Document;
export const DocumentFragment: {
    new (): DocumentFragment;
    prototype: DocumentFragment;
};
export const Object: ObjectConstructor;
export const Promise: PromiseConstructor;
export const requestAnimationFrame: typeof globalThis.requestAnimationFrame;
export const Symbol: SymbolConstructor;
export const queueMicrotask: typeof globalThis.queueMicrotask;
export const assign: {
    <T extends {}, U>(target: T, source: U): T & U;
    <T extends {}, U, V>(target: T, source1: U, source2: V): T & U & V;
    <T extends {}, U, V, W>(target: T, source1: U, source2: V, source3: W): T & U & V & W;
    (target: object, ...sources: any[]): any;
};
export const create: {
    (o: object | null): any;
    (o: object | null, properties: PropertyDescriptorMap & ThisType<any>): any;
};
export const defineProperties: <T>(o: T, properties: PropertyDescriptorMap & ThisType<any>) => T;
export const defineProperty: <T>(o: T, p: PropertyKey, attributes: PropertyDescriptor & ThisType<any>) => T;
export const entries: {
    <T>(o: {
        [s: string]: T;
    } | ArrayLike<T>): [string, T][];
    (o: {}): [string, any][];
};
export const freeze: {
    <T extends Function>(f: T): T;
    <T extends {
        [idx: string]: U | null | undefined | object;
    }, U extends string | bigint | number | boolean | symbol>(o: T): Readonly<T>;
    <T>(o: T): Readonly<T>;
};
export const fromEntries: {
    <T = any>(entries: Iterable<readonly [PropertyKey, T]>): {
        [k: string]: T;
    };
    (entries: Iterable<readonly any[]>): any;
};
export const getOwnPropertyDescriptor: (o: any, p: PropertyKey) => PropertyDescriptor | undefined;
export const getOwnPropertyDescriptors: <T>(o: T) => { [P in keyof T]: TypedPropertyDescriptor<T[P]>; } & {
    [x: string]: PropertyDescriptor;
};
export const getOwnPropertyNames: (o: any) => string[];
export const getOwnPropertySymbols: (o: any) => symbol[];
export const getPrototypeOf: (o: any) => any;
export const groupBy: <K extends PropertyKey, T>(items: Iterable<T>, keySelector: (item: T, index: number) => K) => Partial<Record<K, T[]>>;
export const hasOwnProperty: (o: object, v: PropertyKey) => boolean;
export const is: (value1: any, value2: any) => boolean;
export const isExtensible: (o: any) => boolean;
export const keys: {
    (o: object): string[];
    (o: {}): string[];
};
export const values: {
    <T>(o: {
        [s: string]: T;
    } | ArrayLike<T>): T[];
    (o: {}): any[];
};
export const setPrototypeOf: (o: any, proto: object | null) => any;
export const isArray: (arg: any) => arg is any[];
export const toArray: {
    <T>(arrayLike: ArrayLike<T>): T[];
    <T, U>(arrayLike: ArrayLike<T>, mapfn: (v: T, k: number) => U, thisArg?: any): U[];
    <T>(iterable: Iterable<T> | ArrayLike<T>): T[];
    <T, U>(iterable: Iterable<T> | ArrayLike<T>, mapfn: (v: T, k: number) => U, thisArg?: any): U[];
};
export const isNaN: (number: unknown) => boolean;
export const iterator: symbol;
export const stringify: {
    (value: any, replacer?: (this: any, key: string, value: any) => any, space?: string | number): string;
    (value: any, replacer?: (number | string)[] | null, space?: string | number): string;
};
export function stringifyReadable(o: any): string;
export function stringifySorted(o: any): string;
export const PrototypeArray: any[];
export const PrototypeMap: Map<any, any>;
export const history: History;
export const location: Location;
export const navigator: Navigator;
export const origin: string;
export function promise(fn: any): Promise<any>;
export function withResolvers(): PromiseWithResolvers<any>;
export function resolved(promise: any, onDone: any): any;
export function setAttribute(node: any, name: any, value: any): any;
export function hasAttribute(node: any, name: any): any;
export function removeAttribute(node: any, name: any): any;
export function setAttributeNS(node: any, name: any, value: any): any;
export function hasAttributeNS(node: any, name: any): any;
export function removeAttributeNS(node: any, name: any): any;
export function isConnected(node: any): any;
export function activeElement(): Element | null;
export const documentElement: HTMLElement;
export function call(fns: Iterable<Function>): void;
export function redefineProperty<T>(target: T, key: PropertyKey, descriptor: PropertyDescriptor): T;
export function definePropertyReadOnly<T>(target: T, key: PropertyKey, value: any): void;
export const createElement: any;
export const createElementNS: any;
export const createTextNode: any;
export const createComment: any;
export const importNode: any;
export const createTreeWalker: any;
/**
 * Returns an object without a prototype
 *
 * @type {Function}
 * @returns {Props} Empty object
 */
export const empty: Function;
/**
 * An empty frozen array
 *
 * @type {readonly []}
 */
export const emptyArray: readonly [];
/**
 * An empty frozen object
 *
 * @type object
 */
export const nothing: object;
export function flat(arr: any[] | NodeListOf<ChildNode>): any;
export function withState<T>(fn: T, state?: DataStore<Map<any, any>> | DataStore<WeakMap<any, any>>): T;
export function withCache(fn: any): (cache: any, thing: any) => any;
export function withWeakCache(fn: any): (cache: any, thing: any) => any;
export const walkElements: (node?: any, max?: number | undefined, nodes?: any[] | undefined) => any[];
export function getDocumentForElement(node: Element): Document | ShadowRoot;
export function getOwnValues(o: any): any[];
export function getValueWithArguments(value: any, ...args: any[]): any;
export function identity<T>(x: T): T;
export function isConfigurable(target: object, key: PropertyKey, value: boolean | undefined): boolean | undefined;
export function isFunction(value: any): boolean;
export function isIterable(value: any): boolean;
export function isNullUndefined(value: any): boolean;
export function isObject(value: any): boolean;
export function morphedBetweenArrayAndObject(a: any, b: any): boolean;
export function isPrototypeProperty(target: object, key: PropertyKey): boolean;
export function isString(value: any): boolean;
export function isNumber(value: any): boolean;
export function isSymbol(value: any): boolean;
export function isBoolean(value: any): boolean;
export function isPromise(value: any): boolean;
export function noop(): void;
export function optional(value: Function | boolean | undefined): boolean;
export function partAdd(node: any, className: any): any;
export function partRemove(node: any, className: any): any;
export function querySelector(node: any, query: any): any;
export function querySelectorAll(node: any, query: any): any;
export const reflectOwnKeys: typeof Reflect.ownKeys;
export const reflectHas: typeof Reflect.has;
export const reflectDeleteProperty: typeof Reflect.deleteProperty;
export const reflectGetOwnPropertyDescriptor: typeof Reflect.getOwnPropertyDescriptor;
export const reflectGet: typeof Reflect.get;
export const reflectApply: typeof Reflect.apply;
export const reflectSet: typeof Reflect.set;
export function typeString(obj: any): string;
export function weakStore(): DataStoreT;
export function cacheStore(): DataStoreT;
export function classListAdd(node: any, className: any): any;
export function classListRemove(node: any, className: any): any;
export function adoptedStyleSheetsGet(document: Document | ShadowRoot): CSSStyleSheet[];
export const adoptedStyleSheets: CSSStyleSheet[];
export function adoptedStyleSheetsAdd(document: Document | ShadowRoot, styleSheet: CSSStyleSheet): number;
export function adoptedStyleSheetsRemove(document: Document | ShadowRoot, styleSheet: CSSStyleSheet): void;
export function addStyleSheetExternal(state: any, document: any, text: any): void;
export function animateClassTo(element: Element, oldClass: string, newClass: string): Promise<any>;
export function animatePartTo(element: Element, oldPart: string, newPart: string): Promise<any>;
export function css(template: TemplateStringsArray, ...values: any[]): CSSStyleSheet;
export function sheet(cache: any, thing: any): any;
export function emit(node: Element, eventName: string, data?: any): boolean;
export function preventDefault(e: any): any;
export function stopPropagation(e: any): any;
export function stopImmediatePropagation(e: any): any;
export function waitEvent(state: any, element: any, eventName: any): Promise<any>;
export function addEventNative(where: any, type: any, handler: any): any;
export function removeEventNative(where: any, type: any, handler: any): any;
export function passiveEvent(fn: EventListener): {
    handleEvent: EventListener;
    passive: boolean;
};
export function warn(...args: any[]): void;
export function error(...args: any[]): void;
/**
 * Store template
 */
export type DataStoreGet = (reference: any, createIfNotExistsAs?: ((target: any) => any) | Function) => any;
/**
 * Store template
 */
export type DataStoreSet = (key: any, value: any) => void;
/**
 * Store template
 */
export type DataStoreHas = (key: any) => boolean;
/**
 * Store template
 */
export type DataStoreDelete = (key: any) => boolean;
/**
 * Store template
 */
export type DataStoreT = [DataStoreGet, DataStoreSet, DataStoreHas, DataStoreDelete] & {
    get: DataStoreGet;
    set: DataStoreSet;
    has: DataStoreHas;
    delete: DataStoreDelete;
};
declare class DataStore {
    /** @param {WeakMap | Map} kind */
    constructor(kind: WeakMap<any, any> | Map<any, any>);
    set: any;
    has: any;
    delete: any;
    get: (target: any, defaults?: null) => any;
    [Symbol.iterator](): Generator<any, void, unknown>;
}
export {};
//# sourceMappingURL=std.d.ts.map