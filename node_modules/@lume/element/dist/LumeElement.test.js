var __esDecorate = (this && this.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
var __runInitializers = (this && this.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
import { createEffect } from 'solid-js';
import html from 'solid-js/html';
import { reactive, signal, signalify } from 'classy-solid';
import { Element, element } from './index.js';
import { attribute, numberAttribute } from './attribute.js';
describe('LumeElement', () => {
    it('can be extended by custom element classes', () => {
        let count = 0;
        let MyEl = (() => {
            let _classDecorators = [element('my-el')];
            let _classDescriptor;
            let _classExtraInitializers = [];
            let _classThis;
            let _classSuper = Element;
            var MyEl = class extends _classSuper {
                static { _classThis = this; }
                static {
                    const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
                    __esDecorate(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
                    MyEl = _classThis = _classDescriptor.value;
                    if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
                    __runInitializers(_classThis, _classExtraInitializers);
                }
                connectedCallback() {
                    super.connectedCallback();
                    count++;
                }
            };
            return MyEl = _classThis;
        })();
        document.body.append(new MyEl());
        expect(count).toBe(1);
    });
    it('creates an open shadow root by default (once connected)', () => {
        let MyEl = (() => {
            let _classDecorators = [element('has-shadow')];
            let _classDescriptor;
            let _classExtraInitializers = [];
            let _classThis;
            let _classSuper = Element;
            var MyEl = class extends _classSuper {
                static { _classThis = this; }
                static {
                    const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
                    __esDecorate(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
                    MyEl = _classThis = _classDescriptor.value;
                    if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
                    __runInitializers(_classThis, _classExtraInitializers);
                }
            };
            return MyEl = _classThis;
        })();
        const el = new MyEl();
        expect(el.shadowRoot).toBe(null);
        document.body.append(el);
        expect(el.shadowRoot).toBeInstanceOf(ShadowRoot);
    });
    it("allows opting out of a shadow root by defining the 'root' property", () => {
        const attachShadow = Element.prototype.attachShadow;
        let calls = 0;
        Element.prototype.attachShadow = function (...args) {
            calls++;
            return attachShadow.apply(this, args);
        };
        let div;
        let MyEl = (() => {
            let _classDecorators = [element('no-shadow')];
            let _classDescriptor;
            let _classExtraInitializers = [];
            let _classThis;
            let _classSuper = Element;
            var MyEl = class extends _classSuper {
                static { _classThis = this; }
                static {
                    const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
                    __esDecorate(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
                    MyEl = _classThis = _classDescriptor.value;
                    if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
                    __runInitializers(_classThis, _classExtraInitializers);
                }
                get templateRoot() {
                    return this;
                }
                template = () => {
                    div = document.createElement('div');
                    div.id = 'div';
                    return div;
                };
            };
            return MyEl = _classThis;
        })();
        const el = new MyEl();
        document.body.append(el);
        expect(el.shadowRoot).toBe(null);
        expect(calls).toBe(0);
        // @ts-ignore
        expect(el.querySelector('#div')).toBe(div);
    });
    it('it appends anything returned from template() to a ShadowRoot by default', () => {
        let MyEl = (() => {
            let _classDecorators = [element('append-template')];
            let _classDescriptor;
            let _classExtraInitializers = [];
            let _classThis;
            let _classSuper = Element;
            var MyEl = class extends _classSuper {
                static { _classThis = this; }
                static {
                    const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
                    __esDecorate(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
                    MyEl = _classThis = _classDescriptor.value;
                    if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
                    __runInitializers(_classThis, _classExtraInitializers);
                }
                template = () => {
                    const div = document.createElement('div');
                    div.innerText = 'hello';
                    return div;
                };
            };
            return MyEl = _classThis;
        })();
        const el = new MyEl();
        document.body.append(el);
        expect(el.root.children.length).toBe(2);
        // The DOM element returned from template()
        expect(el.root.firstElementChild.outerHTML).toBe('<div>hello</div>');
        // The style element that LumeElement creates
        expect(el.root.lastElementChild.tagName.toLowerCase()).toBe('style');
    });
    // TODO: JSX support, a .tsx file should be compiled to .js, but currently
    // it is compiled to .jsx without JSX untouched.
    // it('templates with reactivity (with JSX syntax)', () => {
    // 	@element('jsx-template')
    // 	class MyEl extends Element {
    // 		@signal message = 'hello'
    // 		@signal count = 0
    // 		// @ts-expect-error we did not enable Solid JSX types in the test files, so it complains about a React JSX type
    // 		template = () => <div count={this.count}>{this.message}</div>
    // 	}
    // 	const el = new MyEl() as any
    // 	document.body.append(el)
    // 	expect(el.root.children.length).toBe(2)
    // 	// The first element is the style element that LumeElement creates
    // 	expect(el.root.firstElementChild.tagName.toLowerCase()).toBe('style')
    // 	// The DOM element returned from template()
    // 	expect(el.root.lastElementChild.outerHTML).toBe('<div count="0">hello</div>')
    // 	el.message = 'goodbye'
    // 	el.count++
    // 	expect(el.root.lastElementChild.outerHTML).toBe('<div count="1">goodbye</div>')
    // 	// By default the template sets attributes on builtin elements, so the same-name prop is undefined.
    // 	expect(el.root.lastElementChild.count).toBe(undefined)
    // 	// The attribute has the value.
    // 	expect(el.root.lastElementChild.getAttribute('count')).toBe('1')
    // })
    it('templates with reactivity (with the html template string tag)', () => {
        let MyEl = (() => {
            let _classDecorators = [element('html-template')];
            let _classDescriptor;
            let _classExtraInitializers = [];
            let _classThis;
            let _classSuper = Element;
            let _message_decorators;
            let _message_initializers = [];
            let _message_extraInitializers = [];
            let _count_decorators;
            let _count_initializers = [];
            let _count_extraInitializers = [];
            var MyEl = class extends _classSuper {
                static { _classThis = this; }
                static {
                    const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
                    _message_decorators = [signal];
                    _count_decorators = [signal];
                    __esDecorate(null, null, _message_decorators, { kind: "field", name: "message", static: false, private: false, access: { has: obj => "message" in obj, get: obj => obj.message, set: (obj, value) => { obj.message = value; } }, metadata: _metadata }, _message_initializers, _message_extraInitializers);
                    __esDecorate(null, null, _count_decorators, { kind: "field", name: "count", static: false, private: false, access: { has: obj => "count" in obj, get: obj => obj.count, set: (obj, value) => { obj.count = value; } }, metadata: _metadata }, _count_initializers, _count_extraInitializers);
                    __esDecorate(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
                    MyEl = _classThis = _classDescriptor.value;
                    if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
                    __runInitializers(_classThis, _classExtraInitializers);
                }
                message = __runInitializers(this, _message_initializers, 'hello');
                count = (__runInitializers(this, _message_extraInitializers), __runInitializers(this, _count_initializers, 0));
                template = (__runInitializers(this, _count_extraInitializers), () => html `<div count=${() => this.count}>${() => this.message}</div>`);
            };
            return MyEl = _classThis;
        })();
        const el = new MyEl();
        document.body.append(el);
        expect(el.root.children.length).toBe(2);
        // The DOM element returned from template()
        expect(el.root.firstElementChild.outerHTML).toBe('<div count="0">hello</div>');
        // The style element that LumeElement creates
        expect(el.root.lastElementChild.tagName.toLowerCase()).toBe('style');
        el.message = 'goodbye';
        el.count++;
        expect(el.root.firstElementChild.outerHTML).toBe('<div count="1">goodbye</div>');
        // By default the template sets attributes on builtin elements, so the same-name prop is undefined.
        expect(el.root.firstElementChild.count).toBe(undefined);
        // The attribute has the value.
        expect(el.root.firstElementChild.getAttribute('count')).toBe('1');
        // TODO If the prop: prefix was used, then the template sets the JS property on the element. `html` doesn't have namespace prefixes yet.
        // expect(el.root.firstElementChild.theCount).toBe(1)
        /**
         * Simulate a click event.
         * @public
         * @param {Element} elem  the element to simulate a click on
         */
        // var simulateClick = function (elem) {
        // 	// Create our event (with options)
        // 	var evt = new MouseEvent('click', {
        // 		bubbles: true,
        // 		cancelable: true,
        // 		view: window
        // 	});
        // 	// If cancelled, don't dispatch our event
        // 	var canceled = !elem.dispatchEvent(evt);
        // };
    });
    it('same as previous test, but @reactive is required if @element is not used', () => {
        let MyEl = (() => {
            let _classDecorators = [reactive];
            let _classDescriptor;
            let _classExtraInitializers = [];
            let _classThis;
            let _classSuper = Element;
            let _message_decorators;
            let _message_initializers = [];
            let _message_extraInitializers = [];
            let _count_decorators;
            let _count_initializers = [];
            let _count_extraInitializers = [];
            var MyEl = class extends _classSuper {
                static { _classThis = this; }
                static {
                    const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
                    _message_decorators = [signal];
                    _count_decorators = [signal];
                    __esDecorate(null, null, _message_decorators, { kind: "field", name: "message", static: false, private: false, access: { has: obj => "message" in obj, get: obj => obj.message, set: (obj, value) => { obj.message = value; } }, metadata: _metadata }, _message_initializers, _message_extraInitializers);
                    __esDecorate(null, null, _count_decorators, { kind: "field", name: "count", static: false, private: false, access: { has: obj => "count" in obj, get: obj => obj.count, set: (obj, value) => { obj.count = value; } }, metadata: _metadata }, _count_initializers, _count_extraInitializers);
                    __esDecorate(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
                    MyEl = _classThis = _classDescriptor.value;
                    if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
                    __runInitializers(_classThis, _classExtraInitializers);
                }
                message = __runInitializers(this, _message_initializers, 'hello');
                count = (__runInitializers(this, _message_extraInitializers), __runInitializers(this, _count_initializers, 0));
                template = (__runInitializers(this, _count_extraInitializers), () => html `<div count=${() => this.count}>${() => this.message}</div>`);
            };
            return MyEl = _classThis;
        })();
        customElements.define('html-template2', MyEl);
        const el = new MyEl();
        document.body.append(el);
        expect(el.root.children.length).toBe(2);
        expect(el.root.firstElementChild.outerHTML).toBe('<div count="0">hello</div>');
        expect(el.root.lastElementChild.tagName.toLowerCase()).toBe('style');
        el.message = 'goodbye';
        el.count++;
        expect(el.root.firstElementChild.outerHTML).toBe('<div count="1">goodbye</div>');
        expect(el.root.firstElementChild.count).toBe(undefined);
        expect(el.root.firstElementChild.getAttribute('count')).toBe('1');
    });
    it('same as previous test, but using signalify() instead of @reactive', () => {
        class MyEl extends Element {
            message = 'hello';
            count = 0;
            constructor() {
                super();
                signalify(this, 'message', 'count');
            }
            template = () => html `<div count=${() => this.count}>${() => this.message}</div>`;
        }
        customElements.define('html-template2.5', MyEl);
        const el = new MyEl();
        document.body.append(el);
        expect(el.root.children.length).toBe(2);
        expect(el.root.firstElementChild.outerHTML).toBe('<div count="0">hello</div>');
        expect(el.root.lastElementChild.tagName.toLowerCase()).toBe('style');
        el.message = 'goodbye';
        el.count++;
        expect(el.root.firstElementChild.outerHTML).toBe('<div count="1">goodbye</div>');
        expect(el.root.firstElementChild.count).toBe(undefined);
        expect(el.root.firstElementChild.getAttribute('count')).toBe('1');
    });
    it('forgetting to use @reactive, @element, or signalify() causes a runtime error', () => {
        // @reactive <---- user forgets to use the class decorator, or forgets to use `signalify()`
        let MyEl = (() => {
            let _classSuper = Element;
            let _message_decorators;
            let _message_initializers = [];
            let _message_extraInitializers = [];
            let _count_decorators;
            let _count_initializers = [];
            let _count_extraInitializers = [];
            return class MyEl extends _classSuper {
                static {
                    const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
                    _message_decorators = [signal];
                    _count_decorators = [signal];
                    __esDecorate(null, null, _message_decorators, { kind: "field", name: "message", static: false, private: false, access: { has: obj => "message" in obj, get: obj => obj.message, set: (obj, value) => { obj.message = value; } }, metadata: _metadata }, _message_initializers, _message_extraInitializers);
                    __esDecorate(null, null, _count_decorators, { kind: "field", name: "count", static: false, private: false, access: { has: obj => "count" in obj, get: obj => obj.count, set: (obj, value) => { obj.count = value; } }, metadata: _metadata }, _count_initializers, _count_extraInitializers);
                    if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
                }
                message = __runInitializers(this, _message_initializers, 'hello');
                count = (__runInitializers(this, _message_extraInitializers), __runInitializers(this, _count_initializers, 0));
                template = (__runInitializers(this, _count_extraInitializers), () => html `<div count=${() => this.count}>${() => this.message}</div>`);
            };
        })();
        customElements.define('html-template3', MyEl);
        // This class will throw when it detects an extraneous property due to
        // the previous class missing @reactive.
        expect(() => {
            let OtherClass = (() => {
                let _classDecorators = [reactive];
                let _classDescriptor;
                let _classExtraInitializers = [];
                let _classThis;
                let _foo_decorators;
                let _foo_initializers = [];
                let _foo_extraInitializers = [];
                var OtherClass = class {
                    static { _classThis = this; }
                    static {
                        const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(null) : void 0;
                        _foo_decorators = [signal];
                        __esDecorate(null, null, _foo_decorators, { kind: "field", name: "foo", static: false, private: false, access: { has: obj => "foo" in obj, get: obj => obj.foo, set: (obj, value) => { obj.foo = value; } }, metadata: _metadata }, _foo_initializers, _foo_extraInitializers);
                        __esDecorate(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
                        OtherClass = _classThis = _classDescriptor.value;
                        if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
                        __runInitializers(_classThis, _classExtraInitializers);
                    }
                    foo = __runInitializers(this, _foo_initializers, 123);
                    constructor() {
                        __runInitializers(this, _foo_extraInitializers);
                    }
                };
                return OtherClass = _classThis;
            })();
            new OtherClass();
        }).toThrow('Did you forget to use the `@reactive` decorator');
        const el = new MyEl();
        document.body.append(el);
        expect(el.root.children.length).toBe(2);
        expect(el.root.firstElementChild.outerHTML).toBe('<div count="0">hello</div>');
        expect(el.root.lastElementChild.tagName.toLowerCase()).toBe('style');
        const expectation = expect(() => {
            // Error writing to these properties
            el.message = 'goodbye';
            el.count++;
        });
        expectation.not.toThrow();
    });
    // TODO
    xit('TODO attribute passing in templates');
    xit('TODO prop passing in templates');
    xit('TODO css prop');
    xit('TODO static css prop');
    // This sort of thing doesn't usually happen in end-user code, but moreso
    // during custom element upgrade processes during HTML parsing. Generally
    // speaking, an end user won't define a custom element class between
    // creating and using an element. Namely this ensures that frameworks (like
    // Solid which uses cloneNode to create nodes based on JSX templates) will
    // work because they set properties on elements before they are upgraded due
    // to the fact that cloneNode skips upgrade (the cloned node must
    // subsequently be connected to the DOM to get upgraded).
    it('initializes pre-upgrade properties by deleting them and re-assigning them after construction in a microtask, with decorator syntax', async () => {
        const fooEl = document.createElement('foo-element');
        // fooEl is instanceof HTMLElement (not FooElement) at this point (ignore the type cast)
        expect(fooEl).toBeInstanceOf(HTMLElement);
        document.body.append(fooEl);
        fooEl.foo = 1;
        fooEl.bar = 2;
        fooEl.setAttribute('baz', '3');
        fooEl.lorem = 4;
        fooEl.ipsum = 5;
        fooEl.ping = '456';
        fooEl.setAttribute('ping', 'ping');
        fooEl.pong = '456';
        fooEl.setAttribute('pong', 'pong');
        fooEl.bop = 'beep';
        let fooDescriptor = Object.getOwnPropertyDescriptor(fooEl, 'foo');
        let initialValuesHandled = !('value' in fooDescriptor);
        let attributeChangedCalled = false;
        // This triggers the Custom Element upgrade process for fooEl.
        let FooElement = (() => {
            let _classDecorators = [element('foo-element')];
            let _classDescriptor;
            let _classExtraInitializers = [];
            let _classThis;
            let _classSuper = Element;
            let _foo_decorators;
            let _foo_initializers = [];
            let _foo_extraInitializers = [];
            let _foo2_decorators;
            let _foo2_initializers = [];
            let _foo2_extraInitializers = [];
            let _foo3_decorators;
            let _foo3_initializers = [];
            let _foo3_extraInitializers = [];
            let _bar_decorators;
            let _bar_initializers = [];
            let _bar_extraInitializers = [];
            let _baz_decorators;
            let _baz_initializers = [];
            let _baz_extraInitializers = [];
            let _lorem_decorators;
            let _lorem_initializers = [];
            let _lorem_extraInitializers = [];
            let _ping_decorators;
            let _ping_initializers = [];
            let _ping_extraInitializers = [];
            let _pong_decorators;
            let _pong_initializers = [];
            let _pong_extraInitializers = [];
            let _beep_decorators;
            let _beep_initializers = [];
            let _beep_extraInitializers = [];
            let _boop_decorators;
            let _boop_initializers = [];
            let _boop_extraInitializers = [];
            let _bop_decorators;
            let _bop_initializers = [];
            let _bop_extraInitializers = [];
            var FooElement = class extends _classSuper {
                static { _classThis = this; }
                static {
                    const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
                    _foo_decorators = [numberAttribute];
                    _foo2_decorators = [attribute];
                    _foo3_decorators = [attribute({ default: true })];
                    _bar_decorators = [signal];
                    _baz_decorators = [attribute];
                    _lorem_decorators = [signal];
                    _ping_decorators = [attribute];
                    _pong_decorators = [attribute];
                    _beep_decorators = [attribute];
                    _boop_decorators = [signal];
                    _bop_decorators = [signal];
                    __esDecorate(null, null, _foo_decorators, { kind: "field", name: "foo", static: false, private: false, access: { has: obj => "foo" in obj, get: obj => obj.foo, set: (obj, value) => { obj.foo = value; } }, metadata: _metadata }, _foo_initializers, _foo_extraInitializers);
                    __esDecorate(null, null, _foo2_decorators, { kind: "field", name: "foo2", static: false, private: false, access: { has: obj => "foo2" in obj, get: obj => obj.foo2, set: (obj, value) => { obj.foo2 = value; } }, metadata: _metadata }, _foo2_initializers, _foo2_extraInitializers);
                    __esDecorate(null, null, _foo3_decorators, { kind: "field", name: "foo3", static: false, private: false, access: { has: obj => "foo3" in obj, get: obj => obj.foo3, set: (obj, value) => { obj.foo3 = value; } }, metadata: _metadata }, _foo3_initializers, _foo3_extraInitializers);
                    __esDecorate(null, null, _bar_decorators, { kind: "field", name: "bar", static: false, private: false, access: { has: obj => "bar" in obj, get: obj => obj.bar, set: (obj, value) => { obj.bar = value; } }, metadata: _metadata }, _bar_initializers, _bar_extraInitializers);
                    __esDecorate(null, null, _baz_decorators, { kind: "field", name: "baz", static: false, private: false, access: { has: obj => "baz" in obj, get: obj => obj.baz, set: (obj, value) => { obj.baz = value; } }, metadata: _metadata }, _baz_initializers, _baz_extraInitializers);
                    __esDecorate(null, null, _lorem_decorators, { kind: "field", name: "lorem", static: false, private: false, access: { has: obj => "lorem" in obj, get: obj => obj.lorem, set: (obj, value) => { obj.lorem = value; } }, metadata: _metadata }, _lorem_initializers, _lorem_extraInitializers);
                    __esDecorate(null, null, _ping_decorators, { kind: "field", name: "ping", static: false, private: false, access: { has: obj => "ping" in obj, get: obj => obj.ping, set: (obj, value) => { obj.ping = value; } }, metadata: _metadata }, _ping_initializers, _ping_extraInitializers);
                    __esDecorate(null, null, _pong_decorators, { kind: "field", name: "pong", static: false, private: false, access: { has: obj => "pong" in obj, get: obj => obj.pong, set: (obj, value) => { obj.pong = value; } }, metadata: _metadata }, _pong_initializers, _pong_extraInitializers);
                    __esDecorate(null, null, _beep_decorators, { kind: "field", name: "beep", static: false, private: false, access: { has: obj => "beep" in obj, get: obj => obj.beep, set: (obj, value) => { obj.beep = value; } }, metadata: _metadata }, _beep_initializers, _beep_extraInitializers);
                    __esDecorate(null, null, _boop_decorators, { kind: "field", name: "boop", static: false, private: false, access: { has: obj => "boop" in obj, get: obj => obj.boop, set: (obj, value) => { obj.boop = value; } }, metadata: _metadata }, _boop_initializers, _boop_extraInitializers);
                    __esDecorate(null, null, _bop_decorators, { kind: "field", name: "bop", static: false, private: false, access: { has: obj => "bop" in obj, get: obj => obj.bop, set: (obj, value) => { obj.bop = value; } }, metadata: _metadata }, _bop_initializers, _bop_extraInitializers);
                    __esDecorate(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
                    FooElement = _classThis = _classDescriptor.value;
                    if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
                    __runInitializers(_classThis, _classExtraInitializers);
                }
                // @ts-ignore, in case TS complains about overiding an accessor (valid JS)
                templateRoot = this;
                // TODO static readonly hasShadow = false
                // Use both types of decorators so that we ensure both features surive the element upgrade.
                foo = __runInitializers(this, _foo_initializers, 3);
                foo2 = (__runInitializers(this, _foo_extraInitializers), __runInitializers(this, _foo2_initializers, 3.5));
                foo3 = (__runInitializers(this, _foo2_extraInitializers), __runInitializers(this, _foo3_initializers, 3.6));
                bar = (__runInitializers(this, _foo3_extraInitializers), __runInitializers(this, _bar_initializers, 4));
                baz = (__runInitializers(this, _bar_extraInitializers), __runInitializers(this, _baz_initializers, 5));
                lorem = (__runInitializers(this, _baz_extraInitializers), __runInitializers(this, _lorem_initializers, 6));
                ipsum = (__runInitializers(this, _lorem_extraInitializers), 7);
                ping = __runInitializers(this, _ping_initializers, '123');
                pong = (__runInitializers(this, _ping_extraInitializers), __runInitializers(this, _pong_initializers, '123'));
                beep = (__runInitializers(this, _pong_extraInitializers), __runInitializers(this, _beep_initializers, 'beep'));
                boop = (__runInitializers(this, _beep_extraInitializers), __runInitializers(this, _boop_initializers, 'boop'));
                bop = (__runInitializers(this, _boop_extraInitializers), __runInitializers(this, _bop_initializers, 'bop'));
                attributeChangedCallback(a, o, n) {
                    attributeChangedCalled = true;
                    super.attributeChangedCallback?.(a, o, n);
                }
                constructor() {
                    super(...arguments);
                    __runInitializers(this, _bop_extraInitializers);
                }
            };
            return FooElement = _classThis;
        })();
        fooDescriptor = Object.getOwnPropertyDescriptor(fooEl, 'foo');
        initialValuesHandled = !('value' in fooDescriptor);
        expect(initialValuesHandled).toBe(true, 'should have handled pre-upgrade values (they have accessor descriptors)');
        expect(attributeChangedCalled).toBe(true);
        // At this point, fooEl is now instanceof FooElement due to the Custom
        // Element upgrade process.
        expect(fooEl).toBeInstanceOf(FooElement);
        // Pre-upgrade values are in place thanks to the @element class decorator.
        expect(fooEl.foo).toBe(1);
        expect(fooEl.bar).toBe(2);
        expect(fooEl.baz).toBe('3');
        expect(fooEl.lorem).toBe(4);
        expect(fooEl.ipsum).toBe(5, 'non decorated properties should get pre-upgrade values too');
        expect(fooEl.getAttribute('baz')).toBe('3');
        expect(fooEl.ping).toBe('ping');
        expect(fooEl.getAttribute('ping')).toBe('ping');
        expect(fooEl.pong).toBe('pong');
        expect(fooEl.getAttribute('pong')).toBe('pong');
        expect(fooEl.beep).toBe('beep');
        // We haven't explicitly set the attribute, and props don't map back to
        // attributes (for performance). Use `setAttribute` if you intend to set
        // an attribute.
        expect(fooEl.getAttribute('beep')).toBe(null);
        expect(fooEl.boop).toBe('boop');
        expect(fooEl.getAttribute('boop')).toBe(null);
        expect(fooEl.templateRoot).toBe(fooEl);
        fooEl.setAttribute('foo', '456');
        expect(fooEl.foo).toBe(456);
        fooEl.removeAttribute('foo');
        expect(fooEl.foo).toBe(3);
        expect(fooEl.foo2).toBe(3.5);
        fooEl.setAttribute('foo2', '456');
        expect(fooEl.foo2).toBe('456');
        fooEl.removeAttribute('foo2');
        expect(fooEl.foo2).toBe(3.5);
        expect(fooEl.foo3).toBe(3.6);
        fooEl.setAttribute('foo3', '456');
        expect(fooEl.foo3).toBe('456');
        fooEl.removeAttribute('foo3');
        expect(fooEl.foo3).toBe(true);
        let count = 0;
        createEffect(() => {
            fooEl.foo; // reactive
            fooEl.bar; // reactive
            fooEl.baz; // reactive
            fooEl.lorem; // reactive
            fooEl.ipsum; // Not tracked.
            fooEl.beep; // reactive
            fooEl.boop; // Not tracked.
            count++;
        }); // run 1
        expect(count).toBe(1);
        fooEl.foo = 10; // run 2
        expect(count).toBe(2);
        fooEl.bar = 20; // run 3
        expect(count).toBe(3);
        fooEl.lorem = 30; // run 4
        expect(count).toBe(4);
        fooEl.ipsum = 40; // Does not trigger effects.
        expect(count).toBe(4);
        // Sets the prop via attributeChangedCallback, hence triggers effects.
        fooEl.setAttribute('beep', 'bop'); // run 5
        // Reactivity with classy-solid currently triggers immediately (not a microtask).
        // If this expectation fails, check to make sure there are not duplicate solid-js libs.
        // TODO we want effects to run async in the next microtask (use this:
        // https://github.com/solidjs/solid/discussions/943#discussioncomment-6654607)).
        // But we can update this separately in a next step.
        //
        // await null
        expect(count).toBe(5, 'reactivity should be triggered');
        expect(fooEl.foo).toBe(10);
        expect(fooEl.bar).toBe(20);
        expect(fooEl.lorem).toBe(30);
        expect(fooEl.ipsum).toBe(40);
        expect(fooEl.beep).toBe('bop');
        expect(fooEl.getAttribute('beep')).toBe('bop');
        expect(fooEl.bop).toBe('beep'); // pre-upgrade value
        // defer to the next microtask
        await null;
        expect(fooEl.foo).toBe(10);
        expect(fooEl.bar).toBe(20);
        expect(fooEl.baz).toBe('3');
        expect(fooEl.lorem).toBe(30);
        expect(fooEl.ipsum).toBe(40);
        expect(fooEl.ping).toBe('ping');
        expect(fooEl.pong).toBe('pong');
        expect(fooEl.beep).toBe('bop');
        expect(fooEl.getAttribute('beep')).toBe('bop');
        expect(fooEl.boop).toBe('boop');
        expect(fooEl.getAttribute('boop')).toBe(null);
        // TODO test reactive var that wasn't set before the await
        expect(fooEl.bop).toBe('beep', "reactive var that wasn't set before the await should have the pre-upgrade value");
        // Regression fix: The initial prop handling process should not mess with the private
        // variables defined in the LumeElement class, and thus this expectation
        // should still hold after deferral.
        expect(fooEl.templateRoot).toBe(fooEl);
        // TODO also test that unshadowing of pre-upgrade properties works in
        // subclasses of a direct subclass of LumeElement.
    });
    // This test is equivalent to the previous one, but not using decorators.
    // This is what plain JS users would need to do.
    it('initializes pre-upgrade properties by deleting them and re-assigning them after construction in a microtask, no decorator syntax', async () => {
        const fooEl = document.createElement('foo-elemento');
        // fooEl is instanceof HTMLElement (not FooElement) at this point (ignore the type cast)
        expect(fooEl).toBeInstanceOf(HTMLElement);
        document.body.append(fooEl);
        fooEl.foo = 1;
        fooEl.bar = 2;
        fooEl.setAttribute('baz', '3');
        fooEl.lorem = 4;
        fooEl.ipsum = 5;
        fooEl.ping = '456';
        fooEl.setAttribute('ping', 'ping');
        fooEl.pong = '456';
        fooEl.setAttribute('pong', 'pong');
        fooEl.bop = 'beep';
        let fooDescriptor = Object.getOwnPropertyDescriptor(fooEl, 'foo');
        let initialValuesHandled = !('value' in fooDescriptor);
        let attributeChangedCalled = false;
        expect(initialValuesHandled).toBe(false, 'pre-upgrade properties are plain properties');
        // const FooElemento = element(
        const FooElemento = element('foo-elemento')(class FooElemento extends Element {
            // @ts-ignore, in case TS complains about overiding an accessor (valid JS)
            templateRoot = this;
            // When not using decorators, we can define the reactive attributes like this instead.
            static observedAttributeHandlers = {
                foo: attribute.string(),
                baz: attribute.string(),
                ping: attribute.string(),
                pong: attribute.string(),
                beep: attribute.string(),
            };
            foo = 3;
            bar = 4; //
            baz = 5;
            lorem = 6; //
            ipsum = 7;
            ping = '123';
            pong = '123';
            beep = 'beep';
            boop = 'boop'; //
            bop = 'bop'; //
            constructor() {
                super();
                // When not using decorators, we have to do the following for non-attribute properties.
                signalify(this, 'bar', 'lorem', 'boop', 'bop');
            }
            attributeChangedCallback(attr, oldVal, newVal) {
                super.attributeChangedCallback?.(attr, oldVal, newVal);
                attributeChangedCalled = true;
            }
        });
        // We need this in non-decorator usage mode because the element in that
        // case is defined in the next microtask.
        await customElements.whenDefined('foo-elemento');
        // This triggers the Custom Element upgrade process for fooEl.
        // customElements.define('foo-elemento', FooElemento)
        fooDescriptor = Object.getOwnPropertyDescriptor(fooEl, 'foo');
        initialValuesHandled = !('value' in fooDescriptor);
        expect(initialValuesHandled).toBe(true, 'should have handled pre-upgrade values (they have accessor descriptors)');
        expect(attributeChangedCalled).toBe(true, 'should have handled initial attributes');
        // At this point, fooEl is now instanceof FooElement due to the Custom
        // Element upgrade process.
        expect(fooEl).toBeInstanceOf(FooElemento);
        // Pre-upgrade values are in place thanks to the @element class decorator.
        expect(fooEl.foo).toBe(1, 'pre-upgrade values should be in place 1');
        expect(fooEl.bar).toBe(2, 'pre-upgrade values should be in place 2');
        expect(fooEl.baz).toBe('3', 'pre-upgrade values should be in place 3');
        expect(fooEl.lorem).toBe(4, 'pre-upgrade values should be in place 4');
        expect(fooEl.ipsum).toBe(5, 'pre-upgrade values should be in place 5');
        expect(fooEl.getAttribute('baz')).toBe('3', 'pre-upgrade values should be in place 6');
        expect(fooEl.ping).toBe('ping', 'pre-upgrade values should be in place 7');
        expect(fooEl.getAttribute('ping')).toBe('ping', 'pre-upgrade values should be in place 8');
        expect(fooEl.pong).toBe('pong', 'pre-upgrade values should be in place 9');
        expect(fooEl.getAttribute('pong')).toBe('pong', 'pre-upgrade values should be in place 10');
        expect(fooEl.beep).toBe('beep', 'pre-upgrade values should be in place 11');
        // We haven't explicitly set the attribute, and props don't map back to
        // attributes (for performance). Use `setAttribute` if you intend to set
        // an attribute.
        expect(fooEl.getAttribute('beep')).toBe(null, 'pre-upgrade values should be in place 12');
        expect(fooEl.boop).toBe('boop', 'pre-upgrade values should be in place 13');
        expect(fooEl.getAttribute('boop')).toBe(null, 'pre-upgrade values should be in place 14');
        expect(fooEl.templateRoot).toBe(fooEl);
        let count = 0;
        createEffect(() => {
            fooEl.foo;
            fooEl.bar;
            fooEl.baz;
            fooEl.lorem;
            fooEl.ipsum; // Not tracked.
            fooEl.beep;
            fooEl.boop; // Not tracked.
            count++;
        });
        expect(count).toBe(1);
        fooEl.foo = 10; // run 2
        expect(count).toBe(2);
        fooEl.bar = 20; // run 3
        expect(count).toBe(3);
        fooEl.lorem = 30; // run 4
        expect(count).toBe(4);
        fooEl.ipsum = 40; // Does not trigger effects.
        expect(count).toBe(4);
        // Sets the prop via attributeChangedCallback, hence triggers effects.
        fooEl.setAttribute('beep', 'bop'); // run 5
        // Reactivity with classy-solid currently triggers immediately (not a microtask).
        // If this expectation fails, check to make sure there are not duplicate solid-js libs.
        // TODO we want effects to run async in the next microtask (use this:
        // https://github.com/solidjs/solid/discussions/943#discussioncomment-6654607)).
        // But we can update this separately in a next step.
        //
        // await null
        expect(count).toBe(5, 'reactivity should be triggered');
        expect(fooEl.foo).toBe(10, 'reactivity check 1');
        expect(fooEl.bar).toBe(20, 'reactivity check 2');
        expect(fooEl.lorem).toBe(30, 'reactivity check 3');
        expect(fooEl.ipsum).toBe(40, 'reactivity check 4');
        expect(fooEl.beep).toBe('bop', 'reactivity check 5');
        expect(fooEl.getAttribute('beep')).toBe('bop', 'reactivity check 6');
        expect(fooEl.bop).toBe('beep', 'reactivity check 7'); // pre-upgrade value
        // defer to the next microtask
        await null;
        expect(fooEl.foo).toBe(10, 'post-deferral check');
        expect(fooEl.bar).toBe(20, 'post-deferral check');
        expect(fooEl.baz).toBe('3', 'post-deferral check');
        expect(fooEl.lorem).toBe(30, 'post-deferral check');
        expect(fooEl.ipsum).toBe(40, 'post-deferral check');
        expect(fooEl.ping).toBe('ping', 'post-deferral check');
        expect(fooEl.pong).toBe('pong', 'post-deferral check');
        expect(fooEl.beep).toBe('bop', 'post-deferral check');
        expect(fooEl.getAttribute('beep')).toBe('bop', 'post-deferral check');
        expect(fooEl.boop).toBe('boop', 'post-deferral check');
        expect(fooEl.getAttribute('boop')).toBe(null, 'post-deferral check');
        // TODO test reactive var that wasn't set before the await
        expect(fooEl.bop).toBe('beep', "reactive var that wasn't set before the await should have the pre-upgrade value");
        // Regression fix: The initial prop handling process should not mess with the private
        // variables defined in the LumeElement class, and thus this expectation
        // should still hold after deferral.
        expect(fooEl.templateRoot).toBe(fooEl, 'LumeElement base class properties should be intact after upgrade');
    });
    xit('TODO similar to the previous test, but instead of using @reactive + @element, using signalify() with customElements.define() for plain JS environments.');
    it('ensure wrapped @reactive decorator still automatically does not track reactivity in constructors', () => {
        let Foo = (() => {
            let _classDecorators = [element];
            let _classDescriptor;
            let _classExtraInitializers = [];
            let _classThis;
            let _classSuper = Element;
            let _amount_decorators;
            let _amount_initializers = [];
            let _amount_extraInitializers = [];
            var Foo = class extends _classSuper {
                static { _classThis = this; }
                static {
                    const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
                    _amount_decorators = [attribute];
                    __esDecorate(null, null, _amount_decorators, { kind: "field", name: "amount", static: false, private: false, access: { has: obj => "amount" in obj, get: obj => obj.amount, set: (obj, value) => { obj.amount = value; } }, metadata: _metadata }, _amount_initializers, _amount_extraInitializers);
                    __esDecorate(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
                    Foo = _classThis = _classDescriptor.value;
                    if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
                    __runInitializers(_classThis, _classExtraInitializers);
                }
                amount = __runInitializers(this, _amount_initializers, 3);
                constructor() {
                    super(...arguments);
                    __runInitializers(this, _amount_extraInitializers);
                }
            };
            return Foo = _classThis;
        })();
        // previously caused an infinite constructor loop
        let Bar = (() => {
            let _classDecorators = [element('no-loop')];
            let _classDescriptor;
            let _classExtraInitializers = [];
            let _classThis;
            let _classSuper = Foo;
            let _double_decorators;
            let _double_initializers = [];
            let _double_extraInitializers = [];
            var Bar = class extends _classSuper {
                static { _classThis = this; }
                static {
                    const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
                    _double_decorators = [attribute];
                    __esDecorate(null, null, _double_decorators, { kind: "field", name: "double", static: false, private: false, access: { has: obj => "double" in obj, get: obj => obj.double, set: (obj, value) => { obj.double = value; } }, metadata: _metadata }, _double_initializers, _double_extraInitializers);
                    __esDecorate(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
                    Bar = _classThis = _classDescriptor.value;
                    if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
                    __runInitializers(_classThis, _classExtraInitializers);
                }
                double = __runInitializers(this, _double_initializers, 0);
                constructor() {
                    super();
                    __runInitializers(this, _double_extraInitializers);
                    this.double = this.amount * 2; // this read of .amount should not be tracked
                }
            };
            return Bar = _classThis;
        })();
        let b;
        let count = 0;
        function noLoop() {
            createEffect(() => {
                b = new Bar(); // this should not track
                count++;
            });
        }
        expect(noLoop).not.toThrow();
        expect(count).toBe(1);
        const b2 = b;
        b.amount = 4; // hence this should not trigger
        // If the effect ran only once initially, not when setting b.colors,
        // then both variables should reference the same instance
        expect(b).toBe(b2);
        expect(count).toBe(1);
    });
    it('ensure wrapped @reactive decorator still automatically does not track reactivity in constructors even when not the root most decorator', () => {
        let Foo = (() => {
            let _classDecorators = [element];
            let _classDescriptor;
            let _classExtraInitializers = [];
            let _classThis;
            let _classSuper = Element;
            let _amount_decorators;
            let _amount_initializers = [];
            let _amount_extraInitializers = [];
            var Foo = class extends _classSuper {
                static { _classThis = this; }
                static {
                    const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
                    _amount_decorators = [attribute];
                    __esDecorate(null, null, _amount_decorators, { kind: "field", name: "amount", static: false, private: false, access: { has: obj => "amount" in obj, get: obj => obj.amount, set: (obj, value) => { obj.amount = value; } }, metadata: _metadata }, _amount_initializers, _amount_extraInitializers);
                    __esDecorate(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
                    Foo = _classThis = _classDescriptor.value;
                    if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
                    __runInitializers(_classThis, _classExtraInitializers);
                }
                amount = __runInitializers(this, _amount_initializers, 3);
                constructor() {
                    super(...arguments);
                    __runInitializers(this, _amount_extraInitializers);
                }
            };
            return Foo = _classThis;
        })();
        function someOtherDecorator(Class, _context) {
            return class Foo extends Class {
            };
        }
        let Bar = (() => {
            let _classDecorators = [someOtherDecorator, element];
            let _classDescriptor;
            let _classExtraInitializers = [];
            let _classThis;
            let _classSuper = Foo;
            let _double_decorators;
            let _double_initializers = [];
            let _double_extraInitializers = [];
            var Bar = class extends _classSuper {
                static { _classThis = this; }
                static {
                    const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
                    _double_decorators = [attribute];
                    __esDecorate(null, null, _double_decorators, { kind: "field", name: "double", static: false, private: false, access: { has: obj => "double" in obj, get: obj => obj.double, set: (obj, value) => { obj.double = value; } }, metadata: _metadata }, _double_initializers, _double_extraInitializers);
                    __esDecorate(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
                    Bar = _classThis = _classDescriptor.value;
                    if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
                    __runInitializers(_classThis, _classExtraInitializers);
                }
                double = __runInitializers(this, _double_initializers, 0);
                constructor() {
                    super();
                    __runInitializers(this, _double_extraInitializers);
                    this.double = this.amount * 2; // this read of .amount should not be tracked
                }
            };
            return Bar = _classThis;
        })();
        customElements.define('no-loop2', Bar);
        let b;
        let count = 0;
        function noLoop() {
            createEffect(() => {
                b = new Bar(); // this should not track
                count++;
            });
        }
        expect(noLoop).not.toThrow();
        const b2 = b;
        b.amount = 4; // hence this should not trigger
        // If the effect ran only once initially, not when setting b.colors,
        // then both variables should reference the same instance
        expect(b).toBe(b2);
        expect(count).toBe(1);
    });
    it('allows manually calling defineElement on a class to define it a name or its default name, or to give it multiple names', () => {
        const name1 = 'manual-el';
        let ManualEl = (() => {
            let _classDecorators = [element(name1, false)];
            let _classDescriptor;
            let _classExtraInitializers = [];
            let _classThis;
            let _classSuper = Element;
            var ManualEl = class extends _classSuper {
                static { _classThis = this; }
                static {
                    const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
                    __esDecorate(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
                    ManualEl = _classThis = _classDescriptor.value;
                    if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
                    __runInitializers(_classThis, _classExtraInitializers);
                }
            };
            return ManualEl = _classThis;
        })();
        const el = document.createElement(name1);
        document.body.append(el);
        expect(el).not.toBeInstanceOf(ManualEl);
        ManualEl.defineElement();
        ManualEl.defineElement(); // no error
        expect(el).toBeInstanceOf(ManualEl);
        expect(el.tagName.toLowerCase()).toBe(ManualEl.elementName);
        expect(el.tagName.toLowerCase()).toBe(name1);
        const name2 = 'manual-el2';
        const el2 = document.createElement(name2);
        document.body.append(el2);
        const ManualEl2 = ManualEl.defineElement(name2);
        ManualEl.defineElement(name2); // no error
        ManualEl2.defineElement(name2); // no error
        expect(el2).toBeInstanceOf(ManualEl);
        expect(el2).toBeInstanceOf(ManualEl2);
        expect(el2.tagName.toLowerCase()).toBe(ManualEl2.elementName);
        expect(el2.tagName.toLowerCase()).toBe(el2.constructor.elementName);
        expect(el2.tagName.toLowerCase()).toBe(name2);
        // TODO test scoped registries once those are out in browsers.
        // const registry = new CustomElementRegistry()
    });
    it('allows options to be passed to attachShadow() via .shadowOptions', () => {
        let count = 0;
        let ShadowOptions = (() => {
            let _classDecorators = [element('shadow-options')];
            let _classDescriptor;
            let _classExtraInitializers = [];
            let _classThis;
            let _classSuper = Element;
            var ShadowOptions = class extends _classSuper {
                static { _classThis = this; }
                static {
                    const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
                    __esDecorate(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
                    ShadowOptions = _classThis = _classDescriptor.value;
                    if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
                    __runInitializers(_classThis, _classExtraInitializers);
                }
                shadowOptions = {
                    get mode() {
                        count++;
                        return 'open';
                    },
                };
            };
            return ShadowOptions = _classThis;
        })();
        const el = new ShadowOptions();
        document.body.append(el);
        expect(count).toBe(1);
        expect(String(el.shadowRoot)).not.toBe('null');
        el.remove();
        let ShadowOptions2 = (() => {
            let _classDecorators = [element('shadow-options2')];
            let _classDescriptor;
            let _classExtraInitializers = [];
            let _classThis;
            let _classSuper = Element;
            var ShadowOptions2 = class extends _classSuper {
                static { _classThis = this; }
                static {
                    const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
                    __esDecorate(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
                    ShadowOptions2 = _classThis = _classDescriptor.value;
                    if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
                    __runInitializers(_classThis, _classExtraInitializers);
                }
                shadowOptions = {
                    get mode() {
                        count++;
                        return 'closed';
                    },
                };
            };
            return ShadowOptions2 = _classThis;
        })();
        const el2 = new ShadowOptions2();
        document.body.append(el2);
        expect(count).toBe(2);
        expect(String(el2.shadowRoot)).toBe('null');
        el2.remove();
    });
});
//# sourceMappingURL=LumeElement.test.js.map